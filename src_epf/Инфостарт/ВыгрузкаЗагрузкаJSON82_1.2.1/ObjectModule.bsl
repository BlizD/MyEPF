Процедура ОбъектыВJSON() Экспорт

	Если НЕ ЗначениеЗаполнено(ЭтотОбъект.ХранилищеСтруктурыТипов) Тогда
	     ЗаполнитьСтруктуруТипов();
	КонецЕсли; 
	СтруктураТипов = ЭтотОбъект.ХранилищеСтруктурыТипов.Получить();
	
	МассивСсылок = ЭтотОбъект.ПереносимыеОбъекты.ВыгрузитьКолонку("СсылкаНаОбъект");
	МассивОбъектов = Новый Массив;
	Для каждого Элемент Из МассивСсылок Цикл
		Если СтруктураТипов.СоответствиеХМЛ.Получить(ТипЗнч(Элемент))<>Неопределено Тогда
			МассивОбъектов.Добавить(Элемент.ПолучитьОбъект());
		КонецЕсли; 
	КонецЦикла; 
	
	ЭтотОбъект.ТекстJSON = JSON(МассивОбъектов,СтруктураТипов);

КонецПроцедуры

Процедура JSONВОбъекты() Экспорт

	Если НЕ ЗначениеЗаполнено(ЭтотОбъект.ХранилищеСтруктурыТипов) Тогда
	     ЗаполнитьСтруктуруТипов();
	КонецЕсли; 
	СтруктураТипов = ЭтотОбъект.ХранилищеСтруктурыТипов.Получить();
	
	МассивОбъектов = UnJSON(ЭтотОбъект.ТекстJSON,СтруктураТипов);
	Если ТипЗнч(МассивОбъектов)=Тип("Массив") Тогда
		
		ЭтотОбъект.ПереносимыеОбъекты.Очистить();
		Для каждого Элемент Из МассивОбъектов Цикл
			Если СтруктураТипов.СоответствиеОбъектов.Получить(ТипЗнч(Элемент))<>Неопределено Тогда
				НоваяСтрока = ЭтотОбъект.ПереносимыеОбъекты.Добавить();
				НоваяСтрока.СсылкаНаОбъект = Элемент.Ссылка;
				НоваяСтрока.ТипОбъекта = Строка(ТипЗнч(НоваяСтрока.СсылкаНаОбъект))
			Иначе
				ЭтотОбъект.ПереносимыеОбъекты.Добавить().СсылкаНаОбъект = Строка(Элемент);
			КонецЕсли; 
		КонецЦикла; 
		
		//СгруппироватьТипыИВывестиСообщение
		СтруктураОтсутствующихТипов = Новый Структура;
		Для каждого ОтсутствующийТип Из СтруктураТипов.МассивОтсутствующихТипов Цикл
		    СтруктураОтсутствующихТипов.Вставить(СтрЗаменить(ОтсутствующийТип,".",""),ОтсутствующийТип);
		КонецЦикла; 
		Для каждого ОтсутствующийТип Из СтруктураОтсутствующихТипов Цикл
		    Сообщить("Не найден тип данных "+ОтсутствующийТип.Значение);
		КонецЦикла; 
	Иначе
	    Сообщить("Преобразование не удалось");
	КонецЕсли; 
	

КонецПроцедуры
 

Процедура ЗаполнитьСтруктуруТипов()

	
	СоответствиеХМЛ = Новый Соответствие;	
//	СоответствиеХМЛ.Вставить(Тип(<Тип этой 1С базы>),<Тип 1С базы получателя>);
	СоответствиеХМЛ.Вставить(Тип("Дата"),"Дата");
	СоответствиеХМЛ.Вставить(Тип("ВидДвиженияНакопления"),"ВидДвиженияНакопления");
	СоответствиеХМЛ.Вставить(Тип("ДвоичныеДанные"),"ДвоичныеДанные");
	СоответствиеХМЛ.Вставить(Тип("ХранилищеЗначения"),"ХранилищеЗначения");
	СоответствиеХМЛ.Вставить(Тип("УникальныйИдентификатор"),"УникальныйИдентификатор");
	СоответствиеХМЛ.Вставить(Тип("ВидСчета"),"ВидСчета");
//	СоответствиеХМЛ.Вставить(Тип("ДокументСсылка.Поступление"),"ДокументСсылка.ПоступлениеТоваровУслуг");

	СоответствиеОбъектов = Новый Соответствие;	
//  ДЛЯ УКАЗАННЫХ ТУТ ОБЪЕКТОВ ОБЯЗАТЕЛЬНО УКАЗАНИЕ СООТВЕТСТВИЯ ССЫЛОК В СТРУКТУРЕ СоответствиеХМЛ	
//	СоответствиеОбъектов.Вставить(Тип(<Тип объекта этой 1С базы>),<Конструктор нового объекта базы получателя>);
//	СоответствиеОбъектов.Вставить(Тип("ДокументОбъект.Поступление"),"Документы.ПоступлениеТоваровУслуг.СоздатьДокумент()");

	МассивТиповТекст = Новый Массив;
	МассивТиповТекст.Добавить("Дата");
	МассивТиповТекст.Добавить("ВидДвиженияНакопления");
	МассивТиповТекст.Добавить("ДвоичныеДанные");
	МассивТиповТекст.Добавить("ХранилищеЗначения");
	МассивТиповТекст.Добавить("УникальныйИдентификатор");
	МассивТиповТекст.Добавить("ВидСчета");
	
	
	МассивОтсутствующихТипов = Новый Массив;
	
	Для каждого Документ Из Метаданные.Документы Цикл
		СоответствиеХМЛ.Вставить(Тип("ДокументСсылка."+Документ.Имя),"ДокументСсылка."+Документ.Имя);
		СоответствиеОбъектов.Вставить(Тип("ДокументОбъект."+Документ.Имя),"Документы."+Документ.Имя+".СоздатьДокумент()");
		МассивТиповТекст.Добавить("ДокументСсылка."+Документ.Имя);
	КонецЦикла; 
	Для каждого Справочник Из Метаданные.Справочники Цикл
		СоответствиеХМЛ.Вставить(Тип("СправочникСсылка."+Справочник.Имя),"СправочникСсылка."+Справочник.Имя);
		СоответствиеОбъектов.Вставить(Тип("СправочникОбъект."+Справочник.Имя),"Справочники."+Справочник.Имя+".СоздатьЭлемент()");
		МассивТиповТекст.Добавить("СправочникСсылка."+Справочник.Имя);
	КонецЦикла; 
	
	Для каждого ПланВидовХарактеристик Из Метаданные.ПланыВидовХарактеристик Цикл
		СоответствиеХМЛ.Вставить(Тип("ПланВидовХарактеристикСсылка."+ПланВидовХарактеристик.Имя),"ПланВидовХарактеристикСсылка."+ПланВидовХарактеристик.Имя);
		СоответствиеОбъектов.Вставить(Тип("ПланВидовХарактеристикОбъект."+ПланВидовХарактеристик.Имя),"ПланыВидовХарактеристик."+ПланВидовХарактеристик.Имя+".СоздатьЭлемент()");
		МассивТиповТекст.Добавить("ПланВидовХарактеристикСсылка."+ПланВидовХарактеристик.Имя);
	КонецЦикла; 
	Для каждого ПланВидовРасчета Из Метаданные.ПланыВидовРасчета Цикл
		СоответствиеХМЛ.Вставить(Тип("ПланВидовРасчетаСсылка."+ПланВидовРасчета.Имя),"ПланВидовРасчетаСсылка."+ПланВидовРасчета.Имя);
		СоответствиеОбъектов.Вставить(Тип("ПланВидовРасчетаОбъект."+ПланВидовРасчета.Имя),"ПланыВидовРасчета."+ПланВидовРасчета.Имя+".СоздатьВидРасчета()");
		МассивТиповТекст.Добавить("ПланВидовРасчетаСсылка."+ПланВидовРасчета.Имя);
	КонецЦикла; 
	Для каждого ПланСчетов Из Метаданные.ПланыСчетов Цикл
		СоответствиеХМЛ.Вставить(Тип("ПланСчетовСсылка."+ПланСчетов.Имя),"ПланСчетовСсылка."+ПланСчетов.Имя);
		СоответствиеОбъектов.Вставить(Тип("ПланСчетовОбъект."+ПланСчетов.Имя),"ПланыСчетов."+ПланСчетов.Имя+".СоздатьСчет()");
		МассивТиповТекст.Добавить("ПланСчетовСсылка."+ПланСчетов.Имя);
	КонецЦикла; 
	Для каждого Перечисление Из Метаданные.Перечисления Цикл
		СоответствиеХМЛ.Вставить(Тип("ПеречислениеСсылка."+Перечисление.Имя),"ПеречислениеСсылка."+Перечисление.Имя);
		МассивТиповТекст.Добавить("ПеречислениеСсылка."+Перечисление.Имя);
	КонецЦикла; 
	
	СтруктураТипов = Новый Структура("МассивОтсутствующихТипов,МассивТиповТекст,СоответствиеХМЛ,СоответствиеОбъектов,SAVE",МассивОтсутствующихТипов,МассивТиповТекст,СоответствиеХМЛ,СоответствиеОбъектов,Истина);
	ЭтотОбъект.ХранилищеСтруктурыТипов = Новый ХранилищеЗначения(СтруктураТипов);
	

КонецПроцедуры
 


//#Область ПрограммныйИнтерфейс

Функция JSON(Значение,СтруктураТипов) 
	Возврат НеФорматированныйJSON(Значение,СтруктураТипов);	
КонецФункции

Функция UnJSON(СтрJSON,СтруктураТипов) 
	Перем Значение;
	
	Если ПолучитьЗначениеJSON(СтрJSON,СтруктураТипов,Значение)=0 Тогда
		Возврат Значение
	КонецЕсли;
	Возврат Неопределено
КонецФункции

//#КонецОбласти 

//#Область СлужебныеФункции
  
//В функции конструкции условий расставлены по частоте их использования.
//Если кому нибудь удастся более оптимально (в смысле быстродействия) написать,
//то просьба сообщить мне на bigb.forum@gmail.com
Функция НеФорматированныйJSON(Значение,СтруктураТипов=Неопределено)
	
	Если СтруктураТипов=Неопределено Тогда
		СоответствиеХМЛ = Новый Соответствие;
		СоответствиеОбъектов  = Новый Соответствие;
		СтруктураТипов = Новый Структура("СоответствиеХМЛ,СоответствиеОбъектов",СоответствиеХМЛ,СоответствиеОбъектов);
	Иначе
		СоответствиеХМЛ = СтруктураТипов.СоответствиеХМЛ;
		СоответствиеОбъектов  = СтруктураТипов.СоответствиеОбъектов;
	КонецЕсли; 
	
	Разделитель="";
	
	ТипЗн=ТипЗнч(Значение);

	Если ТипЗн=Тип("Строка") Тогда
		Стр=""""+Экранировать(Значение)+""""

	ИначеЕсли ТипЗн=Тип("Число") ИЛИ ТипЗнч(Значение)=Тип("Булево") Тогда
		Стр=XMLСтрока(Значение)

	//ИначеЕсли ТипЗн=Тип("Дата") Тогда
	//	Стр=""""+?(ЗначениеЗаполнено(Значение),XMLСтрока(Значение),"")+""""

	ИначеЕсли ТипЗн=Тип("Структура") Тогда
		Стр="{";
		Для Каждого Параметр Из Значение Цикл
			Стр=Стр+Разделитель+Символы.ПС+""""+Параметр.Ключ+""":"+НеФорматированныйJSON(Параметр.Значение,СтруктураТипов);
			Разделитель=","
		КонецЦикла;
		Стр=Стр+Символы.ПС+"}";

	ИначеЕсли ТипЗн=Тип("Массив") Тогда
		Стр="[";
		Для Каждого Элемент Из Значение Цикл
			Стр=Стр+Разделитель+Символы.ПС+НеФорматированныйJSON(Элемент,СтруктураТипов);
			Разделитель=","
		КонецЦикла;
		Стр=Стр+Символы.ПС+"]";

	ИначеЕсли ТипЗн=Тип("ТаблицаЗначений") Тогда
		Колонки=Значение.Колонки;
		СтруктураТЗ = Новый Структура;
		СтруктураТЗ.Вставить("TYPE","ТаблицаЗначений");
		СтруктураТЗ.Вставить("COLUMNS",Новый Структура);
		СтруктураТЗ.Вставить("ROWS",Новый Массив);
		Для Каждого Колонка Из Колонки Цикл
			СтруктураТЗ.COLUMNS.Вставить(Колонка.Имя,);
		КонецЦикла;
		Для Каждого СтрокаТЗ Из Значение Цикл
			Структура=Новый Структура;
			Для Каждого Колонка Из Колонки Цикл
				Если ЗначениеЗаполнено(СтрокаТЗ[Колонка.Имя]) Тогда
					Структура.Вставить(Колонка.Имя,СтрокаТЗ[Колонка.Имя])
				КонецЕсли; 
			КонецЦикла;
			СтруктураТЗ.ROWS.Добавить(Структура);
		КонецЦикла;
		Стр=НеФорматированныйJSON(СтруктураТЗ,СтруктураТипов)
		
	ИначеЕсли Значение=Неопределено Тогда
		Стр="null"
		
	ИначеЕсли СоответствиеХМЛ.Получить(ТипЗн) <> Неопределено Тогда
		
		ЗначениеСтруктурой = Новый Структура("TYPE,UID",СоответствиеХМЛ.Получить(ТипЗн),XMLСтрока(Значение));
		Стр=НеФорматированныйJSON(ЗначениеСтруктурой,СтруктураТипов)
		
	ИначеЕсли СоответствиеОбъектов.Получить(ТипЗн) <> Неопределено Тогда
		
		ЗначениеСтруктурой = Новый Структура("OBJECT,NEW",Истина,СоответствиеОбъектов.Получить(ТипЗн));
		ЗначениеСтруктурой.Вставить("SAVE",СтруктураТипов.Свойство("SAVE") И СтруктураТипов.SAVE = Истина);
		
		//Значение = Документы.Поступление.НайтиПоНомеру("000000001").ПолучитьОбъект();
		МетаданныеЗначения = Значение.Метаданные();
		
		Для каждого СтандартныйРеквизит Из МетаданныеЗначения.СтандартныеРеквизиты Цикл
		    ЗначениеСтруктурой.Вставить(СтандартныйРеквизит.Имя,Значение[СтандартныйРеквизит.Имя]);
		КонецЦикла; 
		
		ЭтоГруппа = ЗначениеСтруктурой.Свойство("ЭтоГруппа") И ЗначениеСтруктурой.ЭтоГруппа = Истина;
								
		Если ЭтоГруппа Тогда
		    ЗначениеСтруктурой.NEW = СтрЗаменить(ЗначениеСтруктурой.NEW,"СоздатьЭлемент()","СоздатьГруппу()");
		КонецЕсли; 
		Для каждого Реквизит Из МетаданныеЗначения.Реквизиты Цикл
			Если ЭтоГруппа И Реквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента Тогда
				Продолжить;
			КонецЕсли; 
			
			Если ЗначениеЗаполнено(Значение[Реквизит.Имя]) Тогда
				ЗначениеСтруктурой.Вставить(Реквизит.Имя,Значение[Реквизит.Имя]);
			КонецЕсли; 
		КонецЦикла; 
		Для каждого ТабличнаяЧасть Из МетаданныеЗначения.ТабличныеЧасти Цикл
			Если ЭтоГруппа И ТабличнаяЧасть.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента Тогда
				Продолжить;
			КонецЕсли; 

			Если Значение[ТабличнаяЧасть.Имя].Количество()>0 Тогда
			    ЗначениеСтруктурой.Вставить(ТабличнаяЧасть.Имя,Значение[ТабличнаяЧасть.Имя].Выгрузить());
			КонецЕсли; 
		КонецЦикла; 
		Стр=НеФорматированныйJSON(ЗначениеСтруктурой,СтруктураТипов)
	Иначе
		Стр=""""+Экранировать(Значение)+""""
	КонецЕсли;

	Возврат Стр
КонецФункции

Функция ПолучитьЗначениеJSON(СтрJSON,СтруктураТипов,Значение,Позиция=1,Ключ="")
	Перем Кавычка;

	СоответствиеХМЛ           = СтруктураТипов.СоответствиеХМЛ;
	МассивТиповТекст          = СтруктураТипов.МассивТиповТекст;
	МассивОтсутствующихТипов  = СтруктураТипов.МассивОтсутствующихТипов;
	
	ЗначениеВСтроке="";
	Кавычек=0;
	Комментарий=Ложь;
	Строка=Ложь;

	Пока Позиция<=СтрДлина(СтрJSON) Цикл
		ХХ=Сред(СтрJSON,Позиция,2);
		Х=Лев(ХХ,1);
		Позиция=Позиция+1;

		Если Х>" " ИЛИ Строка Тогда //Отсекаем всякий хлам

			Если Комментарий Тогда
				//Это комментарий. Крутимся в цикле пока не встретится конец комментария
				Если ХХ="*/" Тогда
					//Комментарий закончился
					Комментарий=Ложь;
					Позиция=Позиция+1;
				КонецЕсли;

			ИначеЕсли Х="\" Тогда
				Позиция=Позиция+1;
				ХХ=ВРег(ХХ);
				Если ХХ="\""" Тогда ЗначениеВСтроке=ЗначениеВСтроке+""""
				ИначеЕсли ХХ="\\" Тогда ЗначениеВСтроке=ЗначениеВСтроке+"\"
				ИначеЕсли ХХ="\/" Тогда ЗначениеВСтроке=ЗначениеВСтроке+"/"
				ИначеЕсли ХХ="\:" Тогда ЗначениеВСтроке=ЗначениеВСтроке+":"
				ИначеЕсли ХХ="\," Тогда ЗначениеВСтроке=ЗначениеВСтроке+","
				ИначеЕсли ХХ="\B" Тогда ЗначениеВСтроке=ЗначениеВСтроке+Символ(8)
				ИначеЕсли ХХ="\F" Тогда ЗначениеВСтроке=ЗначениеВСтроке+Символы.ПФ //перевод формы (страницы)
				ИначеЕсли ХХ="\N" Тогда ЗначениеВСтроке=ЗначениеВСтроке+Символы.ПС //перевод строки
				ИначеЕсли ХХ="\R" Тогда ЗначениеВСтроке=ЗначениеВСтроке+Символы.ВК //возврат каретки
				ИначеЕсли ХХ="\T" Тогда ЗначениеВСтроке=ЗначениеВСтроке+Символы.ВТаб //символ вертикальной табуляции
				ИначеЕсли ХХ="\U" Тогда
					ЗначениеВСтроке=ЗначениеВСтроке+Символ(Hex2Число(Сред(СтрJSON,Позиция,4))); //шестнадцатиричное число
					Позиция=Позиция+4
				КонецЕсли;

			ИначеЕсли Строка Тогда
				//Если строка не закончилась - то пропускаем управляющие символы
				Если Х=Кавычка Тогда
					//Закончилась строка
					Строка=Ложь;
					Кавычек=Кавычек+1;
				Иначе
					ЗначениеВСтроке=ЗначениеВСтроке+Х;
				КонецЕсли;

			ИначеЕсли ХХ="/*" Тогда
				//Начался комментарий
				Комментарий=Истина;
				Позиция=Позиция+1;

			ИначеЕсли Найти("""'{}[]:,",Х)>0 Тогда
				Если Х="""" ИЛИ Х="'" Тогда
					//Началась строка
					//Строка - коллекция нуля или больше символов Unicode, заключенная в
					//двойные кавычки, используя "\" в качестве символа экранирования.
					//Символ представляется как односимвольная строка.
					//Похожий синтаксис используется в C и Java.
					Строка=Истина;
					Кавычка=Х;
					Кавычек=Кавычек+1;

				ИначеЕсли Х="{" Тогда
					//Начался объект
					//Объект - неупорядоченный набор пар ключ/значение.
					//Объект начинается с "{" и заканчивается "}".
					//Каждое имя сопровождается ":", пары ключ/значение разделяются ",".
					ОбъектСтруктура=Новый Структура;
					//Объект=Новый Структура;
					Пока Истина Цикл
						//Получим ключ и значение
						Ключ="";
						Режим=ПолучитьЗначениеJSON(СтрJSON,СтруктураТипов,Значение,Позиция,Ключ);
						//0 - есть значение и не конец объекта (запятая)
						//1 - есть значение и конец объекта
						//2 - нет значения и не конец объекта (запятая)
						//3 - нет значения и конец объекта
						Если Режим=0 Тогда
							ОбъектСтруктура.Вставить(Ключ,Значение);
						ИначеЕсли Режим=1 Тогда
							ОбъектСтруктура.Вставить(Ключ,Значение);
							Прервать
						ИначеЕсли Режим=3 Тогда
							Прервать
						КонецЕсли;
					КонецЦикла;
					Если ОбъектСтруктура.Свойство("UID") Тогда
						//Это простой ХМЛ тип
						Если МассивТиповТекст.Найти(ОбъектСтруктура.TYPE)<>Неопределено Тогда
							Значение = XMLЗначение(Тип(ОбъектСтруктура.TYPE),ОбъектСтруктура.UID);
						Иначе
							МассивОтсутствующихТипов.Добавить(ОбъектСтруктура.TYPE);
							Значение = ОбъектСтруктура.UID;
						КонецЕсли; 
					ИначеЕсли ОбъектСтруктура.Свойство("OBJECT") Тогда
							//Это объект
							Если ЗначениеЗаполнено(ОбъектСтруктура.Ссылка) И СоответствиеХМЛ.Получить(ТипЗнч(ОбъектСтруктура.Ссылка))<>Неопределено Тогда
								//Получаем объект
								ОбъектИБ = ОбъектСтруктура.Ссылка.ПолучитьОбъект();
								Если ОбъектИБ = Неопределено Тогда
									//Если объекта нет, то создать
									ОбъектИБ = Вычислить(ОбъектСтруктура.NEW); 
									ОбъектИБ.УстановитьСсылкуНового(ОбъектСтруктура.Ссылка);
								КонецЕсли; 
								
								//Проверим соответствие испльзования элементов для групп
								МетаданныеЗначения = ОбъектИБ.Метаданные();
								ЭтоГруппа = ОбъектСтруктура.Свойство("ЭтоГруппа") И ОбъектСтруктура.ЭтоГруппа = Истина;
								Для каждого Реквизит Из МетаданныеЗначения.Реквизиты Цикл
									Если ЭтоГруппа И Реквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента Тогда
										ОбъектСтруктура.Удалить(Реквизит.Имя)
									КонецЕсли; 
								КонецЦикла; 
								//Проверить совпадение подчиненности справочников
								Если ОбъектСтруктура.Свойство("Владелец") И МетаданныеЗначения.Владельцы.Количество()=0 Тогда
									ОбъектСтруктура.Удалить("Владелец")
								КонецЕсли; 
								
								//Заполнить реквизиты
								ЗаполнитьЗначенияСвойств(ОбъектИБ,ОбъектСтруктура);
								//Определить ТЧ и попытаться заполнить
								Для каждого ТабличнаяЧасть Из МетаданныеЗначения.ТабличныеЧасти Цикл
									//Если ТЧ для групп не используется и наш объект группа, то пропустить ТЧ
									Если ЭтоГруппа И ТабличнаяЧасть.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента Тогда
										Продолжить;
									КонецЕсли; 
									//Если есть данные о ТЧ, то заполнить ТЧ, иначе очистить
									Если ОбъектСтруктура.Свойство(ТабличнаяЧасть.Имя) И ТипЗнч(ОбъектСтруктура[ТабличнаяЧасть.Имя]) = Тип("ТаблицаЗначений") Тогда
										ОбъектИБ[ТабличнаяЧасть.Имя].Загрузить(ОбъектСтруктура[ТабличнаяЧасть.Имя]);
									Иначе 
										ОбъектИБ[ТабличнаяЧасть.Имя].Очистить();
									КонецЕсли; 
								КонецЦикла;
								Если ОбъектСтруктура.Свойство("SAVE") И ОбъектСтруктура.SAVE = Истина Тогда
								    ОбъектИБ.ОбменДанными.Загрузка = Истина;
									Попытка
										ОбъектИБ.Записать();
										ТекстСообщения = "Записан объект """+ОбъектИБ+"""";
									Исключение
										ТекстСообщения = "Не удалось записать объект """+ОбъектИБ+"""";
									КонецПопытки; 
									Сообщение = Новый СообщениеПользователю;
									Сообщение.Текст = ТекстСообщения;
									Сообщение.КлючДанных = ОбъектСтруктура.Ссылка;
									Сообщение.Сообщить(); 
								КонецЕсли; 
								Значение = ОбъектИБ;
							Иначе
								Значение = ОбъектСтруктура.Ссылка;
							КонецЕсли; 
					ИначеЕсли ОбъектСтруктура.Свойство("TYPE") Тогда
						Если ОбъектСтруктура.TYPE = "ТаблицаЗначений" Тогда
							//Это таблица
							СтруктураТЗ = Новый Структура;
							ТаблицаРезультата = Новый ТаблицаЗначений;
							Для каждого Колонка Из ОбъектСтруктура.COLUMNS Цикл
								ТаблицаРезультата.Колонки.Добавить(Колонка.Ключ);
							КонецЦикла; 
							Для каждого СтрокаТаблицы Из ОбъектСтруктура.ROWS Цикл
								НоваяСтрока = ТаблицаРезультата.Добавить();
								ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаТаблицы);
							КонецЦикла; 
							Значение= ТаблицаРезультата;
						Иначе
							//Сюда мы попадать не должны
							Сообщить("Тип не определен:"+ОбъектСтруктура.TYPE);
						КонецЕсли; 
					Иначе
						//Иначе это обычная структура
						Значение = ОбъектСтруктура;
					КонецЕсли; 
					Возврат 0
				ИначеЕсли Х="[" Тогда
					//Начался массив
					//Массив - упорядоченная коллекция значений.
					//Массив начинается с "[" и заканчивается "]".
					//Значения разделены ",".
					Массив=Новый Массив;
					Пока Истина Цикл
						Режим=ПолучитьЗначениеJSON(СтрJSON,СтруктураТипов,Значение,Позиция);
						//0 - есть значение и не конец массива (запятая)
						//1 - есть значение и конец массива
						//2 - нет значения и не конец массива (запятая)
						//3 - нет значения и конец массива
						Если Режим=0 Тогда
							Массив.Добавить(Значение);
						ИначеЕсли Режим=1 Тогда
							Массив.Добавить(Значение);
							Прервать
						ИначеЕсли Режим=3 Тогда
							Прервать
						КонецЕсли;
					КонецЦикла;
					Если Массив.Количество() > 0 И ТипЗнч(Массив[0])=Тип("Структура") Тогда
						//Если мы получили массив структур, то это таблица
						ТаблицаРезультата = Новый ТаблицаЗначений;
						Для каждого Колонка Из Массив[0] Цикл
							ТаблицаРезультата.Колонки.Добавить(Колонка.Ключ);
						КонецЦикла; 
						Для каждого СтрокаТаблицы Из Массив Цикл
						    НоваяСтрока = ТаблицаРезультата.Добавить();
							ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаТаблицы);
						КонецЦикла; 
						Значение= ТаблицаРезультата;
					Иначе
						Значение=Массив;
					КонецЕсли; 
					Возврат 0
				ИначеЕсли Х="]" ИЛИ Х="}" Тогда
					//Закончился массив/объект
					Если ЗначениеВСтроке="" И Кавычек=0 Тогда
						Возврат 3 //нет значения и конец массива/объекта
					Иначе
						Значение=ПолучитьЗначениеИзСтроки(ЗначениеВСтроке,Кавычек);
						Возврат 1 //есть значение и конец массива/объекта
					КонецЕсли;
				ИначеЕсли Х=":" Тогда
					Ключ=ЗначениеВСтроке;
					Возврат ПолучитьЗначениеJSON(СтрJSON,СтруктураТипов,Значение,Позиция);

				Иначе
					// запятая
					Прервать
				КонецЕсли;

			Иначе
				ЗначениеВСтроке=ЗначениеВСтроке+Х;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	Если Кавычек>0 Тогда
		Значение=ЗначениеВКавычках(ЗначениеВСтроке);
	Иначе
		Если ЗначениеВСтроке="" Тогда
			Возврат 2
		Иначе
			Значение=ЗначениеБезКавычек(ЗначениеВСтроке)
		КонецЕсли;
	КонецЕсли;
	Возврат 0
КонецФункции

Функция Hex2Число(Hex) Экспорт
	Стр=ВРег(СокрЛП(Hex));
	Dec=0;
	Для Х=1 По СтрДлина(Стр) Цикл
		Dec=Dec+Найти("123456789ABCDEF",Сред(Стр,Х,1))*Pow(16,СтрДлина(Стр)-Х)
	КонецЦикла;
	Возврат Dec
КонецФункции

Функция ПолучитьЗначениеИзСтроки(ЗначениеВСтроке,Кавычек)
	Если Кавычек>0 Тогда
		Возврат ЗначениеВКавычках(ЗначениеВСтроке)
	ИначеЕсли ЗначениеВСтроке="" Тогда
		Возврат Неопределено
	КонецЕсли;
	Возврат ЗначениеБезКавычек(ЗначениеВСтроке)
КонецФункции

Функция ЗначениеВКавычках(ЗначениеВСтроке)
	//Это или строка или дата.
	//Дата пока не обрабатывается (потом надо дописать)
	//Пока всегда возвращаем просто строку
	Возврат ЗначениеВСтроке
КонецФункции

Функция ЗначениеБезКавычек(ЗначениеВСтроке)
	//Это число, булево или null.
	//Хотя здесь могут быть и строки. Например: {Code:123}
	Стр=ВРег(ЗначениеВСтроке);
	Если Стр="TRUE" Тогда Возврат Истина
	ИначеЕсли Стр="FALSE" Тогда Возврат Ложь
	ИначеЕсли Стр="NULL" Тогда Возврат Неопределено
	КонецЕсли;

	//Пробежимся по предполагаемому "числу"
	Экспонента=Ложь;
	ХХ=" ";
	Для Индекс=1 По СтрДлина(Стр) Цикл
		Х=Сред(Стр,Индекс,1);
		Если Найти("0123456789.+-",Х) Тогда
			ХХ=ХХ+Х
		ИначеЕсли Х="E" Тогда
			Экспонента=Истина;
			УУ=XMLЗначение(Тип("Число"),ХХ);
			ХХ=" ";
		Иначе
			Возврат ЗначениеВСтроке //Это точно не число, а строка
		КонецЕсли;
	КонецЦикла;

	ХХ=XMLЗначение(Тип("Число"),ХХ);
	Если Экспонента Тогда
		ХХ=УУ*Pow(10,ХХ)
	КонецЕсли;

	Возврат ХХ
КонецФункции

//Экранирует недопустимые символы
Функция Экранировать(Стр)
	Х=СтрЗаменить(Стр,"\","\\");
	Х=СтрЗаменить(Х,"""","\""");
	//Х=СтрЗаменить(Х,"'","\'"); //??? Не уверен в этой строке. Кто нибудь может подтвердить или опровергнуть нужность этой строки.
	Х=СтрЗаменить(Х,":","\:");
	Х=СтрЗаменить(Х,",","\,");
	Х=СтрЗаменить(Х,"/","\/"); //Тут тоже не уверен, но пока оставлю.
	Х=СтрЗаменить(Х,Символ(8),"\b");
	Х=СтрЗаменить(Х,Символы.ПФ,"\f");
	Х=СтрЗаменить(Х,Символы.ПС,"\n");
	Х=СтрЗаменить(Х,Символы.ВК,"\r");
	Х=СтрЗаменить(Х,Символы.ВТаб,"\t");
	Возврат Х
КонецФункции

//#КонецОбласти

